\chapter{Аналитическая часть}

В данном разделе излагаются математические принципы, лежащие в основе двух методов умножения матриц: классического и алгоритма Винограда.

\section{Матрица}
Матрица~\cite[с.~5]{matrix} --- прямоугольная таблица, образованная из элементов некоторого множества и состоящая из $m$ строк и $n$ столбцов.
Матрица обозначается следующим образом:
\begin{equation}
	A=\begin{pmatrix}
		a_{11} & a_{12} & \cdots & a_{1n} \\
		a_{21} & a_{22} & \cdots & a_{2n} \\
		\cdots & \cdots & \cdots & \cdots \\
		a_{m1} & a_{m2} & \cdots & a_{mn} \\
	\end{pmatrix},
\end{equation}
\noindent где $a_{ij}$ --- элементы матрицы ($i=\overline{1,m}; j=\overline{1,n}$); $i$ --- номер строки; $j$ --- номер столбца; $m~\times~n$ --- размер матрицы.

При работе с матрицами выделяют три основные операции:
\begin{enumerate}
	\item сложение, данное действие выполняется для двух матриц одинакового размера;
	\item умножение, данное действие выполняется для двух таких матриц, что у первой матрицы число столбцов должно быть равно числу строк второй матрицы;
	\item транспонирование, данное действие выполняется для матриц любых размеров.
\end{enumerate}


\section{Стандартный алгоритм}
Пусть даны две матрицы. Матрица $A$, размерностью $m~\times~n$ и матрица $B$, размерностью $n~\times~k$:
\begin{equation}
	A_{m \times n}=\begin{pmatrix}
		a_{11} & a_{12} & \cdots & a_{1n} \\
		a_{21} & a_{22} & \cdots & a_{2n} \\
		\cdots & \cdots & \cdots & \cdots \\
		a_{m1} & a_{m2} & \cdots & a_{mn} \\
	\end{pmatrix},
	B_{n \times k}=\begin{pmatrix}
		b_{11} & b_{12} & \cdots & b_{1k} \\
		b_{21} & b_{22} & \cdots & b_{2k} \\
		\cdots & \cdots & \cdots & \cdots \\
		b_{n1} & b_{n2} & \cdots & b_{nk} \\
	\end{pmatrix},
\end{equation}
\noindent тогда матрица $C$ будет иметь размер $m~\times~k$:
\begin{equation}
	C_{m \times k}=\begin{pmatrix}
		c_{11} & c_{12} & \cdots & c_{1k} \\
		c_{21} & c_{22} & \cdots & c_{2k} \\
		\cdots & \cdots & \cdots & \cdots \\
		c_{m1} & c_{m2} & \cdots & c_{mk} \\
	\end{pmatrix},
\end{equation}
\noindent где
\begin{equation}
	\label{std_mult_eq}
	c_{ij}~=~\sum_{t=1}^{n}~a_{it}~\cdot~b_{tj},~i=\overline{1,m}; j=\overline{1,k}
\end{equation}


\section{Алгоритм Винограда}
В формуле~(\ref{std_mult_eq}) можно заметить, что каждый элемент в результирующей матрице равен скалярному произведению соответствующих строк и столбцов исходных матриц.
Пусть даны два вектора $\overrightarrow{V}~=~(v_1, v_2, \dots, v_n)$ и $\overrightarrow{U}~=~(u_1, u_2, \dots, u_n)$, тогда их скалярное произведение будет записано в виде:
\begin{equation}
	\label{scalar_mult_eq}
	\overrightarrow{V}\cdot\overrightarrow{U}~=~v_1~\cdot~u_1~+~v_2~\cdot~u_2~+~\cdots~+v_n~\cdot~u_n
\end{equation}
Это равенство~(\ref{scalar_mult_eq}) можно представить в виде выражения для чётных $n$ ~(\ref{even_scalar_mult_eq})  и в виде выражения для нечётных $n$ ~(\ref{odd_scalar_mult_eq}) :
\begin{equation}
	\label{even_scalar_mult_eq}
	\begin{matrix}
		\overrightarrow{V}\cdot\overrightarrow{U}~=~(v_1~+~u_2)~\cdot~(v_2~+~u_1)~+~\cdots~(v_{n-1}~+~u_{n})~\cdot~(v_{n}~+~u_{n-1})- \\ -~v_1~\cdot~v_2~-u_1~\cdot~u_2-~\cdots~-v_{n-1}~\cdot~v_{n}~-u_{n-1}~\cdot~u_{n}
	\end{matrix}
\end{equation}
\begin{equation}
	\label{odd_scalar_mult_eq}
	\begin{matrix}
		\overrightarrow{V}\cdot\overrightarrow{U}~=~(v_1~+~u_2)~\cdot~(v_2~+~u_1)~+~\cdots~(v_{n-2}~+~u_{n-1})~\cdot~(v_{n-1}~+~u_{n-2})-\\  -~v_1~\cdot~v_2~-u_1~\cdot~u_2-~\cdots~-v_{n-2}~\cdot~v_{n-1}~-u_{n-2}~\cdot~u_{n-1}~+~v_n~\cdot~u_n
	\end{matrix}
\end{equation}
Произведения вида $q_{i}~\cdot~q_{i+1}$ можно вычислить заранее для каждой из двух матриц: для первой матрицы посчитать произведения элементов для каждой строки, для второй --- для каждого столбца.


\section{Оптимизированный алгоритм Винограда}
В алгоритме Винограда можно дополнительно сократить число арифметических операций за счёт вынесения части вычислений за пределы вложенных циклов. 
Оптимизация основана на двух ключевых приёмах:

\begin{enumerate}
	\item \textbf{Предварительное вычисление постоянных выражений.}  
	Значения, зависящие только от размеров матриц (например, $N-1$, $\lfloor N/2 \rfloor$), вычисляются один раз перед началом умножения. Это избавляет от повторных вычислений в теле циклов.
	
	\item \textbf{Буферизация промежуточных результатов.}  
	При заполнении массивов дополнительно формируются вспомогательные буферы:  
	\begin{itemize}
		\item для каждой строки первой матрицы сохраняются суммы произведений пар элементов;
		\item для каждого столбца второй матрицы аналогично сохраняются накопленные значения.
	\end{itemize}
	Использование буферов позволяет уменьшить количество умножений и сложений при вычислении каждого элемента результирующей матрицы.
\end{enumerate}

Таким образом, оптимизированный алгоритм Винограда, сохраняя идею скалярного произведения строк и столбцов, уменьшает общее количество выполняемых операций. Это делает его более эффективным при работе с матрицами больших размеров.

\section*{Вывод}

В аналитической части были рассмотрены математические основы алгоритма Винограда и стандартного алгоритма умножения матриц.

\clearpage

