\chapter{Технологическая часть}

В данной части приведён выбор инструментов для разработки, представлены листинги реализованных алгоритмов, а также результаты функционального тестирования.

\section{Средства реализации}

Для разработки алгоритмов и программного обеспечения использовался язык программирования \textit{C++}~\cite{cpp}. 
Этот язык обладает статической типизацией, что соответствует требованиям, предъявляемым к лабораторным работам по курсу анализа алгоритмов.

\section{Реализации алгоритмов}

В листинге~\ref{lst_recursive_algo} представлена реализация рекурсивного алгоритма
вывода элементов последовательности с нечётными номерами.

\lstinputlisting[label={lst_recursive_algo}, caption=Реализация рекурсивного алгоритма вывода элементов последовательности с нечётными номерами]{code/code_rec.cpp}

Рекурсивная функция \texttt{printOddPositionsRecursive} выполняет обход элементов входной последовательности.
На каждом шаге функция:
\begin{enumerate}
	\item проверяет, не достигнут ли конец вектора (\texttt{index >= sequence.size()});
	\item если текущий индекс соответствует нечётной позиции, выводит значение элемента на экран;
	\item вызывает саму себя для следующего индекса (\texttt{index + 1}).
\end{enumerate}

Такой подход обеспечивает линейный проход по всем элементам последовательности.  
Главным отличием данного метода является использование стека вызовов: для каждого элемента создаётся новый кадр стека, что увеличивает расход памяти до $O(n)$.

В листинге~\ref{lst_iterative_algo} представлена реализация итеративного алгоритма
вывода элементов последовательности с нечётными номерами.
\clearpage

\lstinputlisting[label={lst_iterative_algo}, caption=Реализация итеративного алгоритма вывода элементов последовательности с нечётными номерами]{code/code_iter.cpp}

В итеративной реализации используется цикл \texttt{for}, проходящий по всем элементам последовательности.
Для каждой позиции вычисляется выражение \texttt{(i + 1) \% 2 != 0}, определяющее нечётность индекса.
Если условие выполняется, элемент выводится на экран.

В отличие от рекурсивного алгоритма, итеративный вариант не создаёт дополнительных кадров стека и использует
фиксированное количество переменных, что обеспечивает константную сложность по памяти $O(1)$
и более высокую производительность при больших размерах входных данных.

\section{Функциональное тестирование}
\begin{table}[H]
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\caption{Функциональные тесты}
	\label{table_tests}
	\begin{center}
		\resizebox{\textwidth}{!}{
			\begin{tabular}{|p{1cm}|p{5cm}|p{4cm}|p{4cm}|}
				\hline
				№ & Описание теста & Входные данные & Ожидаемый результат \\ \hline
				
				1 & Пустая последовательность & $\{\}$ & Пустой вывод \\ \hline
				2 & Последовательность из одного элемента & $\{5\}$ & 5 \\ \hline
				3 & Последовательность из двух элементов & $\{1, 2\}$ & 1 \\ \hline
				4 & Последовательность из трёх элементов & $\{10, 20, 30\}$ & 10 30 \\ \hline
				5 & Последовательность из четырёх элементов & $\{1, 2, 3, 4\}$ & 1 3 \\ \hline
				6 & Последовательность из пяти элементов & $\{5, 10, 15, 20, 25\}$ & 5 15 25 \\ \hline
				7 & Последовательность с отрицательными числами & $\{-1, -2, -3, -4, -5\}$ & -1 -3 -5 \\ \hline
				8 & Последовательность с нулевыми значениями & $\{0, 0, 0, 0, 0, 0\}$ & 0 0 0 \\ \hline
				9 & Смешанная последовательность (положительные и отрицательные) & $\{-10, 5, -3, 8, 0, -1\}$ & -10 -3 0 \\ \hline
				10 & Последовательность с повторяющимися значениями & $\{7, 7, 7, 7, 7, 7\}$ & 7 7 7 \\ \hline
				11 & Последовательность с большими числами & $\{1000, 2000, 3000, 4000\}$ & 1000 3000 \\ \hline
				12 & Длинная последовательность (15 элементов) & $\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\}$ & 1 3 5 7 9 11 13 15 \\ \hline
			\end{tabular}%
		}
	\end{center}
\end{table}



Все приведённые тесты успешно пройдены, что подтверждает правильность работы алгоритмов в различных ситуациях. Оба алгоритма (рекурсивный и итеративный) демонстрируют идентичные результаты для всех тестовых случаев.

\section*{Вывод}

В технологической части были рассмотрены средства реализации и проведено функциональное тестирование алгоритмов вывода элементов последовательности с нечётными номерами; реализованы и проверены две версии алгоритмов --- рекурсивная и итеративная. Для подтверждения корректности работы использовался расширенный набор функциональных тестов, включающий пустые последовательности, последовательности из одного элемента, с отрицательными числами, с нулевыми значениями и последовательности различной длины, результаты которых подтвердили правильность работы обеих реализаций.

Оба алгоритма показали идентичные результаты для всех тестовых случаев, что подтверждает их корректность и согласованность работы. Рекурсивный алгоритм демонстрирует более простую и понятную структуру кода, однако требует больше ресурсов памяти. Итеративный алгоритм более эффективен по использованию ресурсов, но может быть менее интуитивно понятен для некоторых разработчиков.

\clearpage


